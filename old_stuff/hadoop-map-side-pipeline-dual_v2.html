<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Hadoop Map Task Internal Pipeline Simulator (Fixed)</title>
  <style>
    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      margin: 0;
      padding: 20px;
      background: #f8fafc;
      color: #1e293b;
      display: flex;
      justify-content: center;
      min-height: 100vh;
    }

    .app {
      max-width: 1200px;
      width: 100%;
      background: #ffffff;
      border-radius: 16px;
      padding: 20px 24px 28px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.08), 0 0 1px rgba(0,0,0,0.1);
      border: 1px solid #e2e8f0;
    }

    h1 {
      font-size: 24px;
      margin: 0 0 6px;
      color: #0f172a;
      font-weight: 700;
    }

    .subtitle {
      font-size: 14px;
      color: #475569;
      margin-bottom: 16px;
      line-height: 1.5;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 14px;
      flex-wrap: wrap;
    }

    button {
      border-radius: 8px;
      padding: 8px 18px;
      font-size: 14px;
      border: none;
      cursor: pointer;
      background: #16a34a;
      color: #ffffff;
      font-weight: 600;
      box-shadow: 0 2px 8px rgba(22,163,74,0.3);
      transition: all 0.15s ease;
    }

    button:hover:not(:disabled) {
      background: #15803d;
      box-shadow: 0 4px 12px rgba(22,163,74,0.4);
      transform: translateY(-1px);
    }

    button.secondary {
      background: #f1f5f9;
      color: #334155;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      border: 1px solid #cbd5e1;
    }

    button.secondary:hover:not(:disabled) {
      background: #e2e8f0;
      border-color: #94a3b8;
    }

    button.pause {
      background: #ea580c;
      color: #ffffff;
    }

    button.pause:hover:not(:disabled) {
      background: #c2410c;
    }

    button:active:not(:disabled) {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      color: #475569;
      margin-left: auto;
    }

    .speed-control input[type="range"] {
      width: 140px;
      cursor: pointer;
    }

    /* Metrics Panel */
    .metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 12px;
      margin: 16px 0;
      padding: 16px;
      background: #f8fafc;
      border-radius: 12px;
      border: 1px solid #e2e8f0;
    }

    .metric {
      text-align: center;
    }

    .metric-value {
      font-size: 24px;
      font-weight: 700;
      color: #16a34a;
      display: block;
      margin-bottom: 4px;
    }

    .metric-label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #64748b;
    }

    .layout {
      display: grid;
      grid-template-columns: 1.85fr 1fr;
      gap: 18px;
      margin-top: 16px;
    }

    @media (max-width: 968px) {
      .layout {
        grid-template-columns: 1fr;
      }
    }

    .timeline {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
      font-size: 11px;
      overflow-x: auto;
      padding-bottom: 4px;
    }

    .timeline-step {
      flex: 1;
      min-width: 80px;
      padding: 6px 8px;
      border-radius: 8px;
      background: #f8fafc;
      border: 1px solid #e2e8f0;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: all 0.2s ease;
      cursor: help;
      color: #475569;
    }

    .timeline-step:hover {
      background: #f1f5f9;
      border-color: #cbd5e1;
    }

    .timeline-step.active {
      background: linear-gradient(135deg, #16a34a, #15803d);
      border-color: #16a34a;
      color: #ffffff;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(22,163,74,0.3);
    }

    .timeline-step.completed {
      background: #e2e8f0;
      border-color: #cbd5e1;
      color: #64748b;
      opacity: 0.8;
    }

    .pipeline {
      background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
      border-radius: 12px;
      padding: 12px;
      border: 1px solid #e2e8f0;
      min-height: 580px;
      position: relative;
      overflow: hidden;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 16px;
    }

    .row-label {
      width: 100px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #475569;
      font-weight: 600;
    }

    .row-box {
      flex: 1;
      border-radius: 10px;
      border: 1px dashed #cbd5e1;
      background: rgba(255,255,255,0.8);
      padding: 32px 14px 14px;
      min-height: 110px;
      position: relative;
      overflow: hidden;
      transition: border-color 0.3s ease;
    }

    #reducersBox,
    #hdfsBox {
      overflow: visible;
    }

    /* Give the circular buffer extra headroom for more rows of records */
    #bufferBox {
      min-height: 160px;
    }

    .row-box.active {
      border-color: #16a34a;
      border-style: solid;
      box-shadow: 0 0 20px rgba(22,163,74,0.15);
      background: rgba(240,253,244,0.9);
    }

    /* InputFormat / Splits / RecordReaders */
    .input-flow {
      position: absolute;
      inset: 22px 10px 10px 10px;
      display: grid;
      grid-template-columns: auto 24px 1fr 24px 1fr;
      align-items: center;
      gap: 8px;
    }

    .input-format,
    .split-box,
    .reader-box {
      border-radius: 8px;
      padding: 10px 12px;
      background: linear-gradient(135deg, #e0f2fe, #f8fafc);
      border: 1px solid #bfdbfe;
      color: #0f172a;
      font-weight: 700;
      font-size: 12px;
      text-align: center;
      box-shadow: 0 2px 10px rgba(59,130,246,0.2);
    }

    .split-group,
    .reader-group {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(80px, 1fr));
      gap: 8px;
    }

    .reader-box {
      background: linear-gradient(135deg, #dcfce7, #f0fdf4);
      border-color: #bbf7d0;
      box-shadow: 0 2px 10px rgba(34,197,94,0.2);
      font-size: 11px;
    }

    .split-box.active,
    .reader-box.active,
    .input-format.active {
      border-color: #16a34a;
      box-shadow: 0 0 14px rgba(22,163,74,0.35);
      transform: translateY(-1px);
    }

    .split-box.inactive,
    .reader-box.inactive {
      opacity: 0.35;
    }

    .flow-arrow {
      text-align: center;
      color: #475569;
      font-weight: 800;
      font-size: 16px;
    }

    .input-note {
      margin-top: 8px;
      font-size: 12px;
      color: #475569;
    }

    .input-layout {
      display: grid;
      grid-template-columns: 140px 24px 1fr;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    .reader-layout {
      margin-top: 10px;
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .dual-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
      align-items: stretch;
    }

    .mapper-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(320px, 1fr));
      gap: 18px;
    }

    .mapper-card {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      background: linear-gradient(180deg, #ffffff 0%, #f8fafc 100%);
      position: relative;
      padding: 18px 18px 22px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.05);
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 220px;
    }

    .mapper-header {
      font-size: 13px;
      font-weight: 700;
      color: #0f172a;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 4px;
    }

    .mapper-meta {
      font-size: 11px;
      color: #475569;
    }

    .mapper-percentage {
      display: inline-block;
      margin-top: 6px;
      font-size: 11px;
      font-weight: 700;
      color: #16a34a;
    }

    .row-title {
      position: absolute;
      top: 10px;
      left: 12px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #64748b;
      font-weight: 600;
    }

    .buffer-inner {
      position: relative;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      background: rgba(255,255,255,0.95);
      overflow: hidden;
      min-height: 170px;
      padding: 26px 12px 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      align-content: flex-start;
      margin-top: 0;
      flex: 1;
    }

    .buffer-capacity {
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(22,163,74,0.08), transparent 50%);
      opacity: 0.5;
      pointer-events: none;
    }

    .buffer-fill {
      position: absolute;
      inset: auto 0 0 0;
      height: 0;
      background: linear-gradient(to top, rgba(22,163,74,0.25), rgba(22,163,74,0.05));
      transition: height 0.25s ease-out;
      pointer-events: none;
      border-top: 1px solid rgba(22,163,74,0.5);
    }
    
    /* PATCH: Quando il buffer si svuota, nascondiamo il riempimento istantaneamente */
    .buffer-fill.flushing {
      transition: none !important;
      height: 0 !important;
    }

    .buffer-percentage {
      margin-top: 4px;
      font-size: 11px;
      font-weight: 600;
      color: #16a34a;
      text-shadow: 0 0 6px rgba(22,163,74,0.3);
      pointer-events: none;
      display: block;
    }

    .kv-record {
      position: relative;
      min-width: 60px;
      height: 20px;
      padding: 0 6px;
      border-radius: 5px;
      background: #16a34a;
      box-shadow: 0 2px 8px rgba(22,163,74,0.4);
      opacity: 0;
      font-size: 10px;
      color: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      font-weight: 700;
      margin: 2px;
      /* PATCH: Transizioni migliorate e flex-shrink */
      transition: opacity 0.2s ease, transform 0.2s ease, background-color 0.2s;
      flex-shrink: 0; 
    }

    .kv-record.buffer {
      background: #22c55e;
      box-shadow: 0 2px 8px rgba(34,197,94,0.4);
    }

    .kv-record.spill {
      background: #0ea5e9;
      box-shadow: 0 2px 8px rgba(14,165,233,0.4);
    }

    .kv-record.final {
      background: #ea580c;
      box-shadow: 0 2px 8px rgba(234,88,12,0.4);
    }

    .kv-record.reducer {
      background: #9333ea;
      box-shadow: 0 2px 10px rgba(147,51,234,0.5);
      color: #ffffff;
      font-weight: 700;
    }

    .kv-record.combiner-pending {
      opacity: 0.25;
      transform: translateY(-4px) scale(0.96);
      filter: blur(1px);
      box-shadow: 0 0 0 2px rgba(14,165,233,0.25);
      transition: opacity 0.5s ease, transform 0.5s ease, filter 0.5s ease;
    }

    .kv-record.processed-blur {
      opacity: 0.4;
      filter: blur(1px);
    }
      margin: 0 0 8px;
    }

    .spill-files {
      position: relative;
      margin-top: 10px;
      padding: 12px 8px 6px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
      background: rgba(248,250,252,0.8);
      display: flex;
      gap: 10px;
      align-items: flex-start;
      justify-content: center;
    }

    .spill-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 14px;
    }

    .spill-column {
      position: relative;
      padding-top: 22px;
      padding-bottom: 6px;
    }

    .spill-title {
      position: absolute;
      top: 0;
      left: 0;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #475569;
      font-weight: 700;
    }

    .spill-column::before {
      content: "";
      position: absolute;
      top: 10px;
      left: 0;
      right: 0;
      height: 1px;
      background: #e2e8f0;
    }

    .spill-slot {
      flex: 1;
      /* PATCH: Altezza minima e allineamento */
      min-height: 120px;
      align-content: flex-start;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      background: linear-gradient(135deg, #ffffff 0%, #f8fafc 100%);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      padding: 28px 10px 12px;
      margin-top: 16px;
    }
    
    /* PATCH: Feedback visivo slot pieno */
    .spill-slot.has-content {
      background: #f0fdf4;
      border-color: #86efac;
    }

    .spill-label {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 9px;
      text-transform: uppercase;
      color: #64748b;
      letter-spacing: 0.1em;
      font-weight: 600;
    }

    .spill-highlight {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 2px solid rgba(14,165,233,0.6);
      box-shadow: 0 0 20px rgba(14,165,233,0.3), inset 0 0 20px rgba(14,165,233,0.1);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }

    .final-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 16px;
      margin-top: 10px;
    }

    .final-card {
      border: 1px solid #e2e8f0;
      border-radius: 12px;
      background: linear-gradient(180deg, #ffffff 0%, #fff7ed 100%);
      padding: 14px 14px 16px;
      box-shadow: 0 4px 14px rgba(0,0,0,0.05);
      position: relative;
    }

    .final-output {
      position: relative;
      border-radius: 8px;
      border: 1px dashed #cbd5e1;
      background: linear-gradient(135deg, rgba(234,88,12,0.08) 0%, rgba(255,255,255,0.9) 60%);
      overflow: hidden;
      transition: all 0.3s ease;
      min-height: 150px;
      padding: 32px 12px 12px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      align-content: flex-start;
      margin-top: 8px;
    }

    .final-label {
      position: absolute;
      top: 5px;
      left: 10px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: #ea580c;
      font-weight: 600;
    }

    .reducers-inner {
      position: relative;
      display: flex;
      gap: 12px;
      margin-top: 18px;
      padding: 0 6px 6px;
    }

    .reducer-box {
      flex: 1;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      background: linear-gradient(135deg, #faf5ff 0%, #ffffff 60%);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      align-content: flex-start;
      padding: 32px 12px 12px;
      min-height: 170px;
    }

    .reducer-box.active {
      border-color: #9333ea;
      box-shadow: 0 0 20px rgba(147,51,234,0.25);
    }

    .reducer-box.reducing {
      box-shadow: 0 0 24px rgba(147,51,234,0.35);
      background: linear-gradient(135deg, rgba(147,51,234,0.15) 0%, #ffffff 70%);
    }

    .reducer-label {
      position: absolute;
      top: 8px;
      left: 10px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: #9333ea;
      font-weight: 600;
    }

    .hdfs-inner {
      position: relative;
      display: flex;
      gap: 12px;
      margin-top: 16px;
    }

    .hdfs-box {
      flex: 1;
      border-radius: 10px;
      border: 1px dashed #cbd5e1;
      background: linear-gradient(135deg, rgba(16,185,129,0.12) 0%, #ffffff 70%);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
      padding: 36px 14px 14px;
      min-height: 190px;
      display: flex;
      flex-wrap: wrap;
      align-items: flex-start;
      align-content: flex-start;
    }

    .hdfs-box.active {
      border-color: #16a34a;
      box-shadow: 0 0 20px rgba(22,163,74,0.2);
    }

    .kv-record.reducer-output {
      box-shadow: 0 0 10px rgba(99,102,241,0.35);
      border: 1px solid rgba(255,255,255,0.85);
    }

    /* Log Panel */
    .log {
      background: #f8fafc;
      border-radius: 12px;
      padding: 16px;
      border: 1px solid #e2e8f0;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .log-section {
      padding: 12px;
      border-radius: 8px;
      background: #ffffff;
      border: 1px solid #e2e8f0;
    }

    .log-section.current {
      border-color: #16a34a;
      background: rgba(240,253,244,0.6);
    }

    .log-section h3 {
      margin: 0 0 8px;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #64748b;
      font-weight: 600;
    }

    .log-section.current h3 {
      color: #16a34a;
    }

    .log-section p {
      margin: 0;
      font-size: 13px;
      line-height: 1.6;
      color: #334155;
    }

    .log-section strong {
      color: #0f172a;
      font-weight: 600;
    }

    .legend {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
      padding: 12px;
      background: #ffffff;
      border-radius: 8px;
      border: 1px solid #e2e8f0;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 12px;
      color: #475569;
    }

    .legend-box {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      box-shadow: 0 0 8px currentColor;
    }

    .legend-box.buffer { background: #22c55e; color: rgba(34,197,94,0.5); }
    .legend-box.spill { background: #0ea5e9; color: rgba(14,165,233,0.5); }
    .legend-box.final { background: #ea580c; color: rgba(234,88,12,0.5); }
    .legend-box.reducer { background: #9333ea; color: rgba(147,51,234,0.5); }

    /* Tooltip */
    .tooltip {
      position: absolute;
      background: #1e293b;
      color: #f8fafc;
      padding: 8px 12px;
      border-radius: 6px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.2s ease;
      z-index: 1000;
      border: 1px solid #334155;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      max-width: 250px;
      line-height: 1.4;
    }

    /* Progress indicator */
    .progress-bar {
      height: 4px;
      background: #e2e8f0;
      border-radius: 2px;
      overflow: hidden;
      margin: 16px 0 8px;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #16a34a, #15803d);
      width: 0%;
      transition: width 0.3s ease;
      box-shadow: 0 0 10px rgba(22,163,74,0.4);
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Hadoop Map Task Internal Pipeline Simulator</h1>
    <p class="subtitle">
      Interactive visualization of two parallel Hadoop Map Tasks. Watch how key-value pairs 
      (like &lt;cat,1&gt;, &lt;dog,1&gt;, &lt;ant,1&gt;) flow through independent buffers, spill at different times, 
      merge locally per mapper, and are then shuffled together to the correct reducers.
    </p>

    <div class="controls">
      <button id="startBtn">▶ Start Simulation</button>
      <button id="pauseBtn" class="pause" disabled>⏸ Pause</button>
      <button id="resetBtn" class="secondary">↻ Reset</button>
      <div class="speed-control">
        <label for="speedSlider">Speed:</label>
        <input type="range" id="speedSlider" min="0.5" max="3" step="0.25" value="1" />
        <span id="speedLabel">1×</span>
      </div>
    </div>

    <div class="metrics">
      <div class="metric">
        <span class="metric-value" id="recordsProcessed">0</span>
        <span class="metric-label">Records Processed</span>
      </div>
      <div class="metric">
        <span class="metric-value" id="bufferUsage">0%</span>
        <span class="metric-label">Buffer Usage</span>
      </div>
      <div class="metric">
        <span class="metric-value" id="spillCount">0</span>
        <span class="metric-label">Spills Created</span>
      </div>
      <div class="metric">
        <span class="metric-value" id="recordsRead">0</span>
        <span class="metric-label">Records Read</span>
      </div>
      <div class="metric">
        <span class="metric-value" id="splitCount">2</span>
        <span class="metric-label">Input Splits</span>
      </div>
      <div class="metric">
        <span class="metric-value" id="currentPhase">Idle</span>
        <span class="metric-label">Current Phase</span>
      </div>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>

    <div class="layout">
      <div>
        <div class="timeline" id="timeline">
          <div class="timeline-step" title="InputFormat splits the input into logical segments">InputFormat</div>
          <div class="timeline-step" title="RecordReaders pull from different splits">RecordReaders</div>
          <div class="timeline-step" title="Two independent mappers fill their buffers at different speeds">Parallel Mappers & Spills</div>
          <div class="timeline-step" title="All mapper outputs merge into a combined map output">Merge</div>
          <div class="timeline-step" title="Reducers fetch partitions from both mappers">Shuffle</div>
          <div class="timeline-step" title="Final outputs are written to HDFS">Write to HDFS</div>
        </div>

        <div class="pipeline">
          <div class="row">
            <div class="row-label">Input</div>
            <div class="row-box" id="inputBox">
              <div class="row-title">InputFormat &amp; Splits</div>
              <div class="input-layout">
                <div class="input-format" id="inputFormatBox">InputFormat</div>
                <div class="flow-arrow">➜</div>
                <div class="split-group" id="splitGroup">
                  <div class="split-box" id="split0">Split 0</div>
                  <div class="split-box" id="split1">Split 1</div>
                </div>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="row-label">RecordReaders</div>
            <div class="row-box" id="readerRowBox">
              <div class="row-title">RecordReaders by split (one per mapper)</div>
              <div class="reader-layout">
                <div class="reader-group dual-grid" id="readerGroup">
                  <div class="reader-box" id="reader0">RecordReader 0</div>
                  <div class="reader-box" id="reader1">RecordReader 1</div>
                </div>
                <div class="input-note">Split 0 → RR0 → Mapper A, Split 1 → RR1 → Mapper B. They march independently to show real parallelism.</div>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="row-label">Mappers</div>
            <div class="row-box" id="bufferBox">
              <div class="row-title">Two mapper tasks in parallel, each with its own circular buffer</div>
              <div class="mapper-grid">
                <div class="mapper-card" id="mapperCard0">
                  <div class="mapper-header">
                    <span>Mapper A</span>
                    <span class="mapper-meta">Split 0 • RR0</span>
                  </div>
                  <div class="buffer-inner" id="bufferInner0">
                    <div class="buffer-capacity"></div>
                    <div class="buffer-fill" id="bufferFill0"></div>
                  </div>
                  <div class="mapper-percentage" id="bufferPercentage0">0%</div>
                </div>
                <div class="mapper-card" id="mapperCard1">
                  <div class="mapper-header">
                    <span>Mapper B</span>
                    <span class="mapper-meta">Split 1 • RR1</span>
                  </div>
                  <div class="buffer-inner" id="bufferInner1">
                    <div class="buffer-capacity"></div>
                    <div class="buffer-fill" id="bufferFill1"></div>
                  </div>
                  <div class="mapper-percentage" id="bufferPercentage1">0%</div>
                </div>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="row-label">Spill Files</div>
            <div class="row-box" id="spillBox">
              <div class="row-title">Intermediate files on disk (mapper-local)</div>
              <div class="spill-grid">
                <div class="spill-column">
                  <div class="spill-title">Mapper A</div>
                  <div class="spill-files">
                    <div class="spill-slot" id="spill0A">
                      <div class="spill-label">Spill A0</div>
                      <div class="spill-highlight" id="spill0AHighlight"></div>
                    </div>
                    <div class="spill-slot" id="spill1A">
                      <div class="spill-label">Spill A1</div>
                      <div class="spill-highlight" id="spill1AHighlight"></div>
                    </div>
                  </div>
                </div>
                <div class="spill-column">
                  <div class="spill-title">Mapper B</div>
                  <div class="spill-files">
                    <div class="spill-slot" id="spill0B">
                      <div class="spill-label">Spill B0</div>
                      <div class="spill-highlight" id="spill0BHighlight"></div>
                    </div>
                    <div class="spill-slot" id="spill1B">
                      <div class="spill-label">Spill B1</div>
                      <div class="spill-highlight" id="spill1BHighlight"></div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="row">
        <div class="row-label">Final Output</div>
        <div class="row-box" id="finalBox">
          <div class="row-title">Each mapper merges its own spills into a map output (one file per mapper)</div>
          <div class="final-grid">
            <div class="final-card">
              <div class="mapper-header">
                <span>Mapper A</span>
                <span class="mapper-meta">Spill A0 + A1 merged</span>
              </div>
              <div class="final-output" id="finalOutputA">
                <div class="final-label">map_0.out</div>
              </div>
            </div>
            <div class="final-card">
              <div class="mapper-header">
                <span>Mapper B</span>
                <span class="mapper-meta">Spill B0 + B1 merged</span>
              </div>
              <div class="final-output" id="finalOutputB">
                <div class="final-label">map_1.out</div>
              </div>
            </div>
          </div>
        </div>
      </div>

          <div class="row">
            <div class="row-label">Reducers</div>
            <div class="row-box" id="reducersBox">
              <div class="row-title">Shuffle Phase - Data Distribution</div>
              <div class="reducers-inner">
                <div class="reducer-box" id="reducer0">
                  <div class="reducer-label">R0</div>
                </div>
                <div class="reducer-box" id="reducer1">
                  <div class="reducer-label">R1</div>
                </div>
                <div class="reducer-box" id="reducer2">
                  <div class="reducer-label">R2</div>
                </div>
              </div>
            </div>
          </div>

          <div class="row">
            <div class="row-label">HDFS</div>
            <div class="row-box" id="hdfsBox">
              <div class="row-title">Write reducer outputs to HDFS (replicated blocks)</div>
              <div class="hdfs-inner">
                <div class="hdfs-box" id="hdfs0">
                  <div class="reducer-label">R0 ➜ HDFS</div>
                </div>
                <div class="hdfs-box" id="hdfs1">
                  <div class="reducer-label">R1 ➜ HDFS</div>
                </div>
                <div class="hdfs-box" id="hdfs2">
                  <div class="reducer-label">R2 ➜ HDFS</div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="legend">
          <div class="legend-item">
            <div class="legend-box" style="background: #8b5cf6;"></div>
            <span>Partition 0 (R0): cat, car, cup</span>
          </div>
          <div class="legend-item">
            <div class="legend-box" style="background: #ec4899;"></div>
            <span>Partition 1 (R1): dog, day, data, door</span>
          </div>
          <div class="legend-item">
            <div class="legend-box" style="background: #f59e0b;"></div>
            <span>Partition 2 (R2): ant, arm, art, ask</span>
          </div>
        </div>
        
        <p style="font-size: 12px; color: #475569; margin-top: 12px; line-height: 1.5;">
          <strong style="color: #0f172a;">How it works:</strong> Each block shows a specific key like 'cat', 'dog', or 'ant'. 
          Keys are colored by their target reducer partition: <strong style="color: #8b5cf6;">purple</strong> for partition 0 
          (keys: cat, car, cup), <strong style="color: #ec4899;">pink</strong> for partition 1 
          (keys: dog, day, data, door), and <strong style="color: #f59e0b;">orange</strong> for partition 2 
          (keys: ant, arm, art, ask). Watch how keys get sorted alphabetically within each partition during spills, 
          then merged and distributed to the correct reducer.
        </p>
      </div>

      <div class="log">
          <div class="log-section current">
            <h3>Current Step</h3>
            <p id="logCurrent">Click "Start Simulation" to watch two map tasks run in parallel.</p>
          </div>

          <div class="log-section">
            <h3>Next Step</h3>
            <p id="logNext">The simulation will guide you through each phase of the dual map task processing.</p>
          </div>

        <div class="log-section">
          <h3>Details & Insights</h3>
          <p id="logHint">This simulator demonstrates how Hadoop MapReduce handles memory management, 
          disk spilling, and data distribution to reducers across two concurrent map tasks. Watch how each buffer fills at its own pace, 
          triggers spills independently, then hands off partitions to reducers without any fake synchronization.</p>
        </div>
      </div>
    </div>
  </div>

<script>
  // --- ELEMENTI DOM ---
  const startBtn = document.getElementById("startBtn");
  const pauseBtn = document.getElementById("pauseBtn");
  const resetBtn = document.getElementById("resetBtn");
  const speedSlider = document.getElementById("speedSlider");
  const speedLabel = document.getElementById("speedLabel");
  const timeline = document.getElementById("timeline");
  
  // Contenitori principali
  const inputBox = document.getElementById("inputBox");
  const inputFormatBox = document.getElementById("inputFormatBox");
  const readerRowBox = document.getElementById("readerRowBox");
  const bufferBox = document.getElementById("bufferBox");
  const spillBox = document.getElementById("spillBox");
  const finalBox = document.getElementById("finalBox");
  const reducersBox = document.getElementById("reducersBox");
  const hdfsBox = document.getElementById("hdfsBox");

  // Gruppi e Array
  const splitBoxes = Array.from(document.querySelectorAll(".split-box"));
  const readerBoxes = Array.from(document.querySelectorAll(".reader-box"));
  const mapperCards = [document.getElementById("mapperCard0"), document.getElementById("mapperCard1")];
  const bufferInners = [document.getElementById("bufferInner0"), document.getElementById("bufferInner1")];
  const bufferFills = [document.getElementById("bufferFill0"), document.getElementById("bufferFill1")];
  const bufferPercentages = [document.getElementById("bufferPercentage0"), document.getElementById("bufferPercentage1")];
  
  const spillSlots = [
    [document.getElementById("spill0A"), document.getElementById("spill1A")],
    [document.getElementById("spill0B"), document.getElementById("spill1B")]
  ];
  const spillHighlights = [
    [document.getElementById("spill0AHighlight"), document.getElementById("spill1AHighlight")],
    [document.getElementById("spill0BHighlight"), document.getElementById("spill1BHighlight")]
  ];

  const finalOutputs = [document.getElementById("finalOutputA"), document.getElementById("finalOutputB")];
  
  const reducers = [document.getElementById("reducer0"), document.getElementById("reducer1"), document.getElementById("reducer2")];
  const hdfsTargets = [document.getElementById("hdfs0"), document.getElementById("hdfs1"), document.getElementById("hdfs2")];

  // Metriche
  const metricsEl = {
    processed: document.getElementById("recordsProcessed"),
    buffer: document.getElementById("bufferUsage"),
    spills: document.getElementById("spillCount"),
    read: document.getElementById("recordsRead"),
    phase: document.getElementById("currentPhase"),
    progress: document.getElementById("progressFill")
  };

  // Log
  const logEl = {
    current: document.getElementById("logCurrent"),
    next: document.getElementById("logNext"),
    hint: document.getElementById("logHint")
  };

  // --- CONFIGURAZIONE ---
  const CONFIG = {
    TOTAL_SPLITS: 2,
    MAPPERS: [
      { id: 0, label: "Mapper A", delay: 0, speed: 1.0 }, 
      { id: 1, label: "Mapper B", delay: 0.1, speed: 1.2 } 
    ],
    BUFFER_CAPACITY: 16,
    BUFFER_TRIGGER_RATIO: 0.75, // Abbassato leggermente per garantire lo spill visivo
    WORD_KEYS: [
      { key: "cat", partition: 0, color: "#8b5cf6" },
      { key: "car", partition: 0, color: "#8b5cf6" },
      { key: "cup", partition: 0, color: "#8b5cf6" },
      { key: "dog", partition: 1, color: "#ec4899" },
      { key: "data", partition: 1, color: "#ec4899" },
      { key: "door", partition: 1, color: "#ec4899" },
      { key: "ant", partition: 2, color: "#f59e0b" },
      { key: "art", partition: 2, color: "#f59e0b" },
      { key: "ask", partition: 2, color: "#f59e0b" }
    ],
    COMBINE_DELAY: 800, // Più veloce per evitare conflitti
  };

  // --- SEQUENZE DATI ---
  function buildSequence(pattern) {
    return pattern.map((wordData, idx) => ({
      key: wordData.key,
      value: 1,
      partition: wordData.partition,
      color: wordData.color,
      id: idx
    }));
  }

  const mapperSequences = [
    buildSequence([
      CONFIG.WORD_KEYS[0], CONFIG.WORD_KEYS[3], CONFIG.WORD_KEYS[6], CONFIG.WORD_KEYS[1],
      CONFIG.WORD_KEYS[4], CONFIG.WORD_KEYS[0], CONFIG.WORD_KEYS[5], CONFIG.WORD_KEYS[7],
      CONFIG.WORD_KEYS[2], CONFIG.WORD_KEYS[6], CONFIG.WORD_KEYS[3], CONFIG.WORD_KEYS[0],
      CONFIG.WORD_KEYS[8], CONFIG.WORD_KEYS[1], CONFIG.WORD_KEYS[7], CONFIG.WORD_KEYS[3]
    ]),
    buildSequence([
      CONFIG.WORD_KEYS[4], CONFIG.WORD_KEYS[1], CONFIG.WORD_KEYS[6], CONFIG.WORD_KEYS[7],
      CONFIG.WORD_KEYS[5], CONFIG.WORD_KEYS[2], CONFIG.WORD_KEYS[3], CONFIG.WORD_KEYS[8],
      CONFIG.WORD_KEYS[0], CONFIG.WORD_KEYS[4], CONFIG.WORD_KEYS[6], CONFIG.WORD_KEYS[5],
      CONFIG.WORD_KEYS[7], CONFIG.WORD_KEYS[3], CONFIG.WORD_KEYS[1]
    ])
  ];

  // --- FASI (STEPS) ---
  const steps = [
    { id: "inputfmt", label: "InputFormat", duration: 1000, narrative: ["Calculates splits based on file size.", "Logically separates data.", "Preparing purely logical splits."] },
    { id: "readers", label: "RecordReaders", duration: 1000, narrative: ["Opens streams to splits.", "Parses bytes into K,V pairs.", "Streaming begins."] },
    { id: "parallel", label: "Map & Spill", duration: 8000, narrative: ["Buffers fill, sort, and spill.", "Spills are written to local disk.", "Memory pressure management."] }, // Tempo aumentato per godersi l'animazione
    { id: "merge", label: "Merge (Sort)", duration: 2000, narrative: ["Merging local spills.", "Creating single map output file.", "Sorting ensures reduced I/O later."] },
    { id: "shuffle", label: "Shuffle/Copy", duration: 2000, narrative: ["Reducers fetch partitions.", "Network transfer happens here.", "Data is regrouped by reducer."] },
    { id: "hdfs", label: "Reduce & Write", duration: 2000, narrative: ["Reduce function runs.", "Output written to HDFS.", "Job Complete."] }
  ];

  // --- STATO GLOBALE ---
  let simulationState = getInitialState();

  function getInitialState() {
    return {
      mapperStates: CONFIG.MAPPERS.map(() => ({
        buffer: [],
        spills: [[], []], // Logica dei dati negli spill
        spilledFlags: [false, false], // Flag per sapere se lo spill è avvenuto
        recordsRead: 0,
        final: []
      })),
      reducerRecords: [], // Record in arrivo ai reducer
      reducerOutputs: [[], [], []], // Output finale HDFS
      
      // Controllo flusso
      started: false,
      paused: false,
      currentStepIndex: 0,
      stepStartTime: null,
      pausedTime: 0,
      speedFactor: 1,
      animationId: null,
      
      // Flag per logica "once"
      executedEvents: new Set() 
    };
  }

  // --- HELPER VISUALI ---
  
  function createRecordElement(container, data, type) {
    const el = document.createElement("div");
    el.className = `kv-record ${type}`;
    el.textContent = data.count ? `(${data.key}, ${data.count})` : `(${data.key}, 1)`;
    el.style.backgroundColor = data.color;
    
    // Animazione entrata
    el.style.opacity = "0";
    el.style.transform = "scale(0.8)";
    container.appendChild(el);
    
    requestAnimationFrame(() => {
      el.style.opacity = "1";
      el.style.transform = "scale(1)";
    });
    return el;
  }

  function clearContainer(container) {
    container.innerHTML = '';
    container.classList.remove('has-content');
  }

  // --- LOGICA CORE ---

  function updateMetrics() {
    // Calcolo totale buffer in uso
    const currentBufferTotal = simulationState.mapperStates.reduce((acc, m) => acc + m.buffer.length, 0);
    const capacityTotal = CONFIG.BUFFER_CAPACITY * 2;
    const usage = Math.round((currentBufferTotal / capacityTotal) * 100);

    metricsEl.processed.textContent = simulationState.mapperStates.reduce((acc, m) => acc + m.recordsRead, 0);
    metricsEl.buffer.textContent = `${usage}%`;
    metricsEl.spills.textContent = simulationState.mapperStates.reduce((acc, m) => acc + m.spilledFlags.filter(Boolean).length, 0);
    metricsEl.read.textContent = metricsEl.processed.textContent;
    
    const step = steps[simulationState.currentStepIndex];
    metricsEl.phase.textContent = step ? step.label : "Done";
  }

  function logEvent(key, message) {
    if (simulationState.executedEvents.has(key)) return;
    simulationState.executedEvents.add(key);
    console.log(`[${key}] ${message}`);
    // Opzionale: aggiornare logCurrent con l'ultimo evento
    logEl.current.innerHTML += `<br><small>&bull; ${message}</small>`;
  }

  // 1. INPUT FORMAT & READERS
  function handleInputPhase() {
    inputBox.classList.add("active");
    inputFormatBox.classList.add("active");
    splitBoxes.forEach(b => b.classList.add("active"));
    logEvent("Input", "InputFormat calculated 2 splits.");
  }

  function handleReaderPhase() {
    readerRowBox.classList.add("active");
    readerBoxes.forEach(b => b.classList.add("active"));
    logEvent("Readers", "RecordReaders opened for Split 0 and Split 1.");
  }

  // 2. MAP & SPILL (Il cuore del problema)
  function handleMapPhase(progress) {
    bufferBox.classList.add("active");
    spillBox.classList.add("active");
    mapperCards.forEach(c => c.classList.add("active"));

    CONFIG.MAPPERS.forEach((cfg, idx) => {
      const state = simulationState.mapperStates[idx];
      const seq = mapperSequences[idx];
      
      // Calcolo quanti record dovremmo aver letto a questo punto
      // Usiamo progress ma lo mappiamo sulle sequenze
      let adjustedProgress = (progress - cfg.delay) * cfg.speed * 1.5; // 1.5 acceleratore
      if (adjustedProgress < 0) adjustedProgress = 0;
      if (adjustedProgress > 1) adjustedProgress = 1;

      const targetCount = Math.floor(seq.length * adjustedProgress);

      // LOOP DI RIEMPIMENTO
      while (state.recordsRead < targetCount) {
        const nextRec = seq[state.recordsRead];
        
        // Aggiorna stato logico
        state.buffer.push(nextRec);
        state.recordsRead++;
        
        // Aggiorna UI Buffer
        createRecordElement(bufferInners[idx], nextRec, "buffer");
        
        // Aggiorna Barre
        const fillPct = (state.buffer.length / CONFIG.BUFFER_CAPACITY) * 100;
        bufferFills[idx].style.height = `${fillPct}%`;
        bufferPercentages[idx].textContent = `${Math.round(fillPct)}%`;

        // CHECK SPILL
        if (state.buffer.length / CONFIG.BUFFER_CAPACITY >= CONFIG.BUFFER_TRIGGER_RATIO) {
          triggerSpill(idx);
        }
      }

      // Se alla fine della fase abbiamo ancora roba nel buffer, forziamo uno spill finale (flush)
      if (progress >= 0.98 && state.buffer.length > 0) {
        triggerSpill(idx, true); // true = force flush
      }
    });
  }

  function triggerSpill(mapperIdx, force = false) {
    const state = simulationState.mapperStates[mapperIdx];
    
    // Trova slot libero
    let slotIdx = state.spilledFlags.indexOf(false);
    
    // Se forziamo il flush e non c'è spazio, usiamo l'ultimo (o gestiamo overflow logico)
    if (slotIdx === -1) {
       if(!force) return; // Buffer full, wait logic (non implementata qui, ma nel vero hadoop si blocca)
       slotIdx = 1; // Sovrascriviamo l'ultimo per visualizzazione (o ignoriamo)
    }

    const spillData = [...state.buffer]; // Copia dati
    // LOGICA SORTING LOCALE
    spillData.sort((a, b) => {
        if (a.partition !== b.partition) return a.partition - b.partition;
        return a.key.localeCompare(b.key);
    });

    // Svuota Buffer Logico
    state.spills[slotIdx] = spillData;
    state.buffer = [];
    state.spilledFlags[slotIdx] = true;

    // Svuota Buffer Visivo (Visual Flash)
    bufferFills[mapperIdx].classList.add("flushing");
    bufferFills[mapperIdx].style.height = "0%";
    setTimeout(() => bufferFills[mapperIdx].classList.remove("flushing"), 100);
    bufferPercentages[mapperIdx].textContent = "0%";
    clearContainer(bufferInners[mapperIdx]);

    // Riempi Spill Slot Visivo
    const targetSlot = spillSlots[mapperIdx][slotIdx];
    const highlight = spillHighlights[mapperIdx][slotIdx];
    
    targetSlot.classList.add("has-content");
    highlight.style.opacity = 1;
    setTimeout(() => highlight.style.opacity = 0, 500);

    // "Combiner" Effect immediato: mostriamo i dati aggregati
    renderSpillContent(targetSlot, spillData);
    
    logEvent(`Spill-${mapperIdx}-${slotIdx}`, `Mapper ${mapperIdx} spilled ${spillData.length} records to disk (Slot ${slotIdx}).`);
  }

  function renderSpillContent(container, data) {
    clearContainer(container);
    // Combiner semplificato per visualizzazione: unisci chiavi identiche
    const combined = [];
    const map = new Map();
    data.forEach(d => {
        const k = d.partition + "|" + d.key;
        if(!map.has(k)) map.set(k, { ...d, count: 0 });
        map.get(k).count++;
    });
    map.forEach(val => combined.push(val));

    combined.forEach(d => {
      createRecordElement(container, d, "spill");
    });
  }

  // 3. MERGE
  function handleMergePhase() {
    finalBox.classList.add("active");
    
    CONFIG.MAPPERS.forEach((_, idx) => {
      const state = simulationState.mapperStates[idx];
      if (state.final.length > 0) return; // Già fatto

      // Pulisci visivamente gli slot spill perché li stiamo "leggendo e consumando"
      spillSlots[idx].forEach(slot => {
          slot.style.opacity = "0.5"; // Feedback visivo che sono stati consumati
      });

      // Merge logico di tutti gli spill
      let allRecords = [];
      state.spills.forEach(spill => allRecords.push(...spill));
      
      // Sort finale
      allRecords.sort((a, b) => {
        if (a.partition !== b.partition) return a.partition - b.partition;
        return a.key.localeCompare(b.key);
      });

      // Aggregazione finale (Map Output)
      const combined = [];
      const map = new Map();
      allRecords.forEach(d => {
          const k = d.partition + "|" + d.key;
          if(!map.has(k)) map.set(k, { ...d, count: d.count || 1 });
          else map.get(k).count += (d.count || 1);
      });
      map.forEach(val => combined.push(val));
      
      state.final = combined;

      // Rendering
      const outputContainer = finalOutputs[idx];
      clearContainer(outputContainer); // Sicurezza
      combined.forEach(d => createRecordElement(outputContainer, d, "final"));
      
      logEvent(`Merge-${idx}`, `Mapper ${idx} merged spills into map_${idx}.out`);
    });
  }

  // 4. SHUFFLE
  function handleShufflePhase(progress) {
    reducersBox.classList.add("active");
    reducers.forEach(r => r.classList.add("active"));

    // Trasferiamo visivamente tutto subito all'inizio della fase per chiarezza
    if (simulationState.executedEvents.has("ShuffleDone")) return;

    // Raccogli tutti i record finali dai mapper
    let pendingReducerRecords = [[], [], []];
    simulationState.mapperStates.forEach(mState => {
        mState.final.forEach(rec => {
            pendingReducerRecords[rec.partition].push(rec);
        });
    });

    // Render nei reducer
    pendingReducerRecords.forEach((recs, partIdx) => {
        const container = reducers[partIdx];
        if(recs.length > 0 && container.children.length <= 1) { // <=1 per contare la label
             recs.forEach(r => createRecordElement(container, r, "reducer"));
        }
    });

    logEvent("ShuffleDone", "Reducers pulled partitions from map outputs via HTTP.");
  }

  // 5. HDFS (Reduce finale)
  function handleHdfsPhase() {
    hdfsBox.classList.add("active");
    hdfsTargets.forEach(h => h.classList.add("active"));

    if (simulationState.executedEvents.has("HdfsDone")) return;

    // Eseguiamo la "reduce" (somma conteggi)
    reducers.forEach((rContainer, idx) => {
        // Prendiamo i dati dal DOM del reducer o dallo stato pending
        // Per semplicità, ricalcoliamo dagli output dei mapper
        let totalCounts = new Map();
        
        simulationState.mapperStates.forEach(mState => {
            mState.final.filter(r => r.partition === idx).forEach(r => {
                if(!totalCounts.has(r.key)) totalCounts.set(r.key, { ...r, count: 0 });
                totalCounts.get(r.key).count += r.count;
            });
        });

        const hdfsContainer = hdfsTargets[idx];
        clearContainer(hdfsContainer);
        
        totalCounts.forEach(val => {
            createRecordElement(hdfsContainer, val, "final");
        });
        
        // Segna i reducer come "done" visivamente
        rContainer.classList.add("completed");
    });

    logEvent("HdfsDone", "Reducers wrote final aggregations to HDFS.");
  }


  // --- LOOP DI ANIMAZIONE ---
  function animateStep(timestamp) {
    if (!simulationState.started || simulationState.paused) return;

    if (!simulationState.stepStartTime) simulationState.stepStartTime = timestamp;
    
    const step = steps[simulationState.currentStepIndex];
    
    // Fine simulazione
    if (!step) {
      simulationState.started = false;
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      startBtn.textContent = "Simulation Complete";
      return;
    }

    // Calcolo progresso
    const elapsed = (timestamp - simulationState.stepStartTime) * simulationState.speedFactor;
    const progress = Math.min(1, elapsed / step.duration);
    
    metricsEl.progress.style.width = `${((simulationState.currentStepIndex + progress) / steps.length) * 100}%`;

    // Dispatcher Fasi
    switch(step.id) {
        case "inputfmt": handleInputPhase(); break;
        case "readers": handleReaderPhase(); break;
        case "parallel": handleMapPhase(progress); break;
        case "merge": handleMergePhase(); break;
        case "shuffle": handleShufflePhase(progress); break;
        case "hdfs": handleHdfsPhase(); break;
    }

    updateMetrics();
    
    // Aggiorna testi Log (solo se cambiato step)
    if(logEl.current.dataset.step !== step.id) {
        logEl.current.dataset.step = step.id;
        logEl.current.innerHTML = `<strong>${step.label}</strong><br>${step.narrative[0]}`;
        logEl.next.innerHTML = `<strong>Next:</strong> ${steps[simulationState.currentStepIndex + 1] ? steps[simulationState.currentStepIndex + 1].label : "Finish"}`;
        logEl.hint.innerHTML = step.narrative[1];
        
        // Highlight timeline
        document.querySelectorAll(".timeline-step").forEach((el, i) => {
            el.classList.toggle("active", i === simulationState.currentStepIndex);
            el.classList.toggle("completed", i < simulationState.currentStepIndex);
        });
    }

    // Transizione step
    if (progress >= 1) {
      simulationState.currentStepIndex++;
      simulationState.stepStartTime = null;
    }

    simulationState.animationId = requestAnimationFrame(animateStep);
  }

  // --- CONTROLLI UTENTE ---
  startBtn.addEventListener("click", () => {
    if(simulationState.started) return;
    simulationState.started = true;
    startBtn.disabled = true;
    pauseBtn.disabled = false;
    resetBtn.disabled = false;
    simulationState.animationId = requestAnimationFrame(animateStep);
  });

  pauseBtn.addEventListener("click", () => {
    simulationState.paused = !simulationState.paused;
    pauseBtn.textContent = simulationState.paused ? "Resume" : "Pause";
    if (!simulationState.paused) {
        // Reset del tempo per evitare salti
        simulationState.stepStartTime = null; 
        simulationState.animationId = requestAnimationFrame(animateStep);
    }
  });

  resetBtn.addEventListener("click", () => {
    cancelAnimationFrame(simulationState.animationId);
    simulationState = getInitialState();
    
    // PULIZIA DOM PROFONDA
    const allDynamicContainers = [
        ...bufferInners, 
        ...spillSlots.flat(), 
        ...finalOutputs, 
        ...reducers, 
        ...hdfsTargets
    ];
    
    allDynamicContainers.forEach(el => {
        el.innerHTML = '';
        // Hack: se abbiamo cancellato label statiche (es. "R0"), le rimettiamo
        // Ma nel layout HTML le label "R0" sono dentro .reducer-label che sono fratelli dei .kv-record,
        // o in alcuni casi figli diretti.
        // NOTA: In questa implementazione, clearContainer pulisce tutto. 
        // Tuttavia, le label (es. <div class="reducer-label">R0</div>) sono figli dei box.
        // Dobbiamo ripristinarle se necessario o evitare di cancellarle.
    });
    
    // Ripristino manuale label critiche se perse (semplificazione)
    if(reducers[0].children.length === 0) reducers[0].innerHTML = '<div class="reducer-label">R0</div>';
    if(reducers[1].children.length === 0) reducers[1].innerHTML = '<div class="reducer-label">R1</div>';
    if(reducers[2].children.length === 0) reducers[2].innerHTML = '<div class="reducer-label">R2</div>';
    if(hdfsTargets[0].children.length === 0) hdfsTargets[0].innerHTML = '<div class="reducer-label">R0 ➜ HDFS</div>';
    if(hdfsTargets[1].children.length === 0) hdfsTargets[1].innerHTML = '<div class="reducer-label">R1 ➜ HDFS</div>';
    if(hdfsTargets[2].children.length === 0) hdfsTargets[2].innerHTML = '<div class="reducer-label">R2 ➜ HDFS</div>';
    
    spillSlots.flat().forEach((s, i) => {
         // Le label degli spill sono sopra gli slot nel DOM HTML, quindi s.innerHTML pulisce solo il contenuto record
         // Ma wait, nel DOM originale <div class="spill-label">Spill A0</div> è DENTRO .spill-slot
         // Quindi dobbiamo ripristinarlo.
         const row = Math.floor(i / 2);
         const col = i % 2;
         const letter = row === 0 ? 'A' : 'B';
         s.innerHTML = `<div class="spill-label">Spill ${letter}${col}</div><div class="spill-highlight" id="${s.id}Highlight"></div>`;
    });
    
    finalOutputs.forEach((f, i) => {
        f.innerHTML = `<div class="final-label">map_${i}.out</div>`;
    });


    // Reset Classi CSS
    const allActive = document.querySelectorAll(".active, .completed, .has-content");
    allActive.forEach(el => el.classList.remove("active", "completed", "has-content"));
    
    bufferFills.forEach(b => b.style.height = "0%");
    bufferPercentages.forEach(b => b.textContent = "0%");
    spillHighlights.flat().forEach(h => h.style.opacity = 0);
    spillSlots.flat().forEach(s => s.style.opacity = "1");
    
    metricsEl.progress.style.width = "0%";
    startBtn.disabled = false;
    startBtn.textContent = "Start Simulation";
    pauseBtn.disabled = true;
    
    updateMetrics();
    logEl.current.innerHTML = "Ready.";
    logEl.next.innerHTML = "";
    logEl.hint.innerHTML = "";
  });

  speedSlider.addEventListener("input", (e) => {
    simulationState.speedFactor = parseFloat(e.target.value);
    speedLabel.textContent = simulationState.speedFactor + "x";
  });

</script>
</body>
</html>